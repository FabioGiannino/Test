
[*PER la strada: o la si crea prima della mappa, oppure avvio il pathfinding che, se fallisce, fa rigenerare la mappa. si ripete finchè non c'è una strada sensata]


spawn solo di due tiles, in posizioni randomiche della mappa.

calcolare le tiles adiacenti. a quel punto fare le regole (es. metto un array che ha 4 copie di lago e una copia di montagna. le tiles adiacenti sono un calcolo di queste probabilità).
le tiles adiacenti appena nate dovranno tenere conto delle vicine già riempite per calcolare la probabilità delle tiles vuote.

si ripete finchè tutta la mappa non è riempita.


1.Read the input bitmap and count NxN patterns.
    i.(optional) Augment pattern data with rotations and reflections.
2.Create an array with the dimensions of the output (called "wave" in the source). Each element of this array represents a state of an NxN region in the output. A state of an NxN region is a superposition of NxN patterns of the input with boolean coefficients (so a state of a pixel in the output is a superposition of input colors with real coefficients).    False coefficient means that the corresponding pattern is forbidden, true coefficient means that the corresponding pattern is not yet forbidden.
3.Initialize the wave in the completely unobserved state, i.e. with all the boolean coefficients being true.
4.Repeat the following steps:
    i.Observation:
        a.Find a wave element with the minimal nonzero entropy. If there is no such elements (if all elements have zero or undefined entropy) then break the cycle (4) and go to step (5).
        b.Collapse this element into a definite state according to its coefficients and the distribution of NxN patterns in the input.
    ii.Propagation: propagate information gained on the previous observation step.
5.By now all the wave elements are either in a completely observed state (all the coefficients except one being zero) or in the contradictory state (all the coefficients being zero).
    In the first case return the output. In the second case finish the work without returning anything.


1.Leggi la bitmap in input e conta i pattern NxN.
    i. (opzionale) Arricchisci i dati dei pattern con rotazioni e riflessioni.
2.Crea un array con le dimensioni dell'output (chiamato "wave" nel codice sorgente). Ogni elemento di questo array rappresenta uno stato di una regione NxN nell'output. Uno stato di una regione NxN è una sovrapposizione di pattern NxN dell'input con coefficienti booleani (quindi uno stato di un pixel nell'output è una sovrapposizione di colori dell'input con coefficienti reali). Un coefficiente falso significa che il pattern corrispondente è vietato, un coefficiente vero significa che il pattern corrispondente non è ancora vietato.
3.Inizializza la wave nello stato completamente non osservato, ovvero con tutti i coefficienti booleani che sono veri.
4.Ripeti i seguenti passi:
    i. Osservazione:
        a. Trova un elemento della wave con entropia minima non nulla. Se non ci sono tali elementi (se tutti gli elementi hanno entropia zero o non definita) allora interrompi il ciclo (4) e passa al passo (5).
        b. Collassa questo elemento in uno stato definito in base ai suoi coefficienti e alla distribuzione di pattern NxN nell'input.
    ii. Propagazione: propaga le informazioni ottenute nel passo di osservazione precedente.
5.Adesso tutti gli elementi della wave sono o in uno stato completamente osservato (tutti i coefficienti tranne uno sono zero) o in uno stato contraddittorio (tutti i coefficienti sono zero). Nel primo caso restituisci l'output. Nel secondo caso termina il lavoro senza restituire nulla.




se int






